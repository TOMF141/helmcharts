## Global parameters
##
global:
  imageRegistry: ""
  imagePullSecrets: []
  defaultStorageClass: ""
  ## Compatibility adaptations for Kubernetes platforms
  ##
  compatibility:
    openshift:
      adaptSecurityContext: auto
    omitEmptySeLinuxOptions: false

## Common parameters
##
kubeVersion: ""
apiVersions: []
nameOverride: ""
fullnameOverride: ""
namespaceOverride: ""
commonLabels: {}
commonAnnotations: {}
clusterDomain: cluster.local
extraDeploy: []
diagnosticMode:
  enabled: false
  command:
  - sleep
  args:
  - infinity

## Primary workload parameters (Deployment)
##
primary:
  ## Tautulli image
  image:
    registry: lscr.io
    repository: linuxserver/tautulli
    tag: latest
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    debug: false
  ## Deployment parameters
  replicaCount: 1
  updateStrategy:
    type: RollingUpdate
    # rollingUpdate settings from v1 strategy.rollingUpdate can be added if needed,
    # but RollingUpdate type often uses defaults. Let's omit for now.
    ## Container ports
  containerPorts:
    # Renaming the default http/https ports to match Tautulli's single port
    http: 8181
  livenessProbe:
    enabled: true
    # Using common chart's structure, assuming httpGet probe on the http port
    httpGet:
      path: /status
      port: http
    initialDelaySeconds: 30
    periodSeconds: 60
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1 # Default
  readinessProbe:
    enabled: false
  startupProbe:
    enabled: false
  resourcesPreset: "none"
  resources:
    limits:
      memory: 2Gi
    requests:
      cpu: 50m
      memory: 1Gi
  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    readOnlyRootFilesystem: false
    privileged: false
    allowPrivilegeEscalation: false
    capabilities:
      drop: [ "ALL" ]
    seccompProfile:
      type: "RuntimeDefault"
  command: []
  args: []
  automountServiceAccountToken: false
  hostAliases: []
  deploymentAnnotations: {}
  podLabels: {}
  podAnnotations: {}
  podAffinityPreset: ""
  podAntiAffinityPreset: soft
  nodeAffinityPreset:
    type: ""
    key: ""
    values: []
  affinity: {}
  nodeSelector: {}
  tolerations: []
  priorityClassName: ""
  topologySpreadConstraints: []
  schedulerName: ""
  terminationGracePeriodSeconds: ""
  lifecycleHooks: {}
  extraEnvVars:
  - name: TZ
    value: "Europe/London"
  - name: PUID
    value: "1000"
  - name: PGID
    value: "1000"
  - name: UMASK
    value: "002"
  - name: DOCKER_MODS
    value: "ghcr.io/gilbn/theme.park:tautulli"
  - name: TP_THEME
    value: "space-gray"
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraVolumes: []
  extraVolumeMounts: []
  ## Sidecars and Init Containers
  sidecars: []
  initContainers: []
  ## Pod Disruption Budget
  pdb:
    create: true
    minAvailable: ""
    maxUnavailable: ""
  autoscaling:
    ## @param primary.autoscaling.vpa.enabled Enable VPA for primary pods
    ##
    vpa:
      enabled: false
      annotations: {}
      controlledResources: []
      maxAllowed: {}
      minAllowed: {}
      ## @param primary.autoscaling.vpa.updatePolicy.updateMode Autoscaling update policy
      ##
      updatePolicy:
        updateMode: Auto
    ## @param primary.autoscaling.hpa.enabled Enable HPA for primary pods
    ##
    hpa:
      enabled: false
      minReplicas: ""
      maxReplicas: ""
      targetCPU: ""
      targetMemory: ""

## Service Parameters
##
service:
  type: ClusterIP
  ports:
    http: 8181
  nodePorts:
    http: ""
    https: ""
  clusterIP: ""
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  externalTrafficPolicy: Cluster
  annotations: {}
  extraPorts: []
  sessionAffinity: None
  sessionAffinityConfig: {}

## Network Policies
##
networkPolicy:
  enabled: false
  allowExternal: true
  allowExternalEgress: true
  addExternalClientAccess: true
  extraIngress: []
  extraEgress: []
  ingressPodMatchLabels: {}
  ingressNSMatchLabels: {}
  ingressNSPodMatchLabels: {}

## Ingress Parameters
##
ingress:
  enabled: false
  pathType: ImplementationSpecific
  apiVersion: ""
  hostname: tautulli.local
  ingressClassName: ""
  path: /
  annotations: {}
  tls: false
  selfSigned: false
  extraHosts: []
  extraPaths: []
  extraTls: []
  secrets: []

## Persistence Parameters (for /config volume)
## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
##
persistence:
  ## @param persistence.enabled Enable persistence using Persistent Volume Claims or other storage types
  ##
  enabled: true
  ## @param persistence.type Type of persistence to use. Possible values: `pvc`, `nfs`, `iscsi`
  ##
  type: pvc
  ## @param persistence.mountPath Path to mount the volume at.
  ##
  mountPath: /config
  ## @param persistence.subPath The subdirectory of the volume to mount to, useful in dev environments and one PV for multiple services
  ## Only used when persistence.type is `pvc`
  ##
  subPath: "" # Keep existing subPath logic if needed for PVC

  ## PVC configuration
  ## Only used when persistence.type is `pvc`
  ##
  pvc:
    ## @param persistence.pvc.storageClass Storage class of backing PVC
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.
    ##
    storageClass: ""
    ## @param persistence.pvc.annotations Persistent Volume Claim annotations
    ##
    annotations: {}
    ## @param persistence.pvc.accessModes Persistent Volume Access Modes
    ##
    accessModes:
    - ReadWriteOnce
    ## @param persistence.pvc.size Size of data volume
    ##
    size: 1Gi
    ## @param persistence.pvc.existingClaim The name of an existing PVC to use for persistence
    ##
    existingClaim: ""
    ## @param persistence.pvc.selector Selector to match an existing Persistent Volume for data PVC
    ## If set, the PVC can't have a PV dynamically provisioned for it
    ##
    selector: {}
    ## @param persistence.pvc.dataSource Custom PVC data source
    ##
    dataSource: {}

  ## NFS configuration
  ## Only used when persistence.type is `nfs`
  ## ref: https://kubernetes.io/docs/concepts/storage/volumes/#nfs
  ##
  nfs:
    ## @param persistence.nfs.server NFS server address
    ##
    server: ""
    ## @param persistence.nfs.path Path exported by the NFS server
    ##
    path: ""
    ## @param persistence.nfs.readOnly Mount the NFS volume as read-only
    ##
    readOnly: false

  ## iSCSI configuration
  ## Only used when persistence.type is `iscsi`
  ## ref: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
  ##
  iscsi:
    ## @param persistence.iscsi.targetPortal iSCSI target portal (IP or hostname)
    ##
    targetPortal: ""
    ## @param persistence.iscsi.iqn iSCSI target IQN (iSCSI Qualified Name)
    ##
    iqn: ""
    ## @param persistence.iscsi.lun iSCSI target LUN number
    ##
    lun: 0
    ## @param persistence.iscsi.fsType Filesystem type to mount (e.g., ext4, xfs)
    ##
    fsType: ext4
    ## @param persistence.iscsi.readOnly Mount the iSCSI volume as read-only
    ##
    readOnly: false
    ## @param persistence.iscsi.secretRef Secret containing iSCSI CHAP authentication credentials (optional)
    ## secretRef:
    ##   name: my-iscsi-secret
    ##
    secretRef: {}

## Init Container Parameters
##
volumePermissions:
  enabled: false
  image:
    registry: docker.io
    repository: bitnami/os-shell
    tag: 12-debian-12-r19
    pullPolicy: IfNotPresent
    pullSecrets: []
  resourcesPreset: "nano"
  resources: {}
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 0

## Other Parameters
##
rbac:
  create: false
  rules: []

serviceAccount:
  create: true
  name: ""
  annotations: {}
  automountServiceAccountToken: true

metrics:
  enabled: false
  serviceMonitor:
    enabled: false
    namespace: ""
    annotations: {}
    labels: {}
    jobLabel: ""
    honorLabels: false
    interval: ""
    scrapeTimeout: ""
    metricRelabelings: []
    relabelings: []
    selector: {}
